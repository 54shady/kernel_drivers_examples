# Locks in linux kernel

## 为什么需要内核锁

多核处理器下,会存在多个进程处于内核态的情况,而在内核态下,
进程是可以访问所有内核数据的,因此要对共享数据进行保护,即互斥处理

## 有哪些内核锁机制

- 原子操作

atomic_t数据类型,atomic_inc(atomic_t *v)将v加1
原子操作比普通操作效率要低,因此必要时才使用,且不能与普通操作混合使用
如果是单核处理器,则原子操作与普通操作相同

- 自旋锁

spinlock_t数据类型,spin_lock(&lock)和spin_unlock(&lock)是加锁和解锁
等待解锁的进程将反复检查锁是否释放,而`不会进入睡眠状态(忙等待)`,
所以常用于`短期`保护某段代码

同时,持有自旋锁的进程也`不允许睡眠`,
不然会造成死锁——因为睡眠可能造成持有锁的进程被重新调度,
而再次申请自己已持有的锁

如果是单核处理器,则自旋锁定义为空操作,因为简单的关闭中断即可实现互斥

- 信号量与互斥量

struct semaphore数据类型,down(struct semaphore * sem)和
up(struct semaphore * sem)是占用和释放

struct mutex数据类型,mutex_lock(struct mutex *lock)和
mutex_unlock(struct mutex *lock)是加锁和解锁

竞争信号量与互斥量时需要进行进程睡眠和唤醒,
代价较高,所以不适于短期代码保护,适用于保护`较长的临界区`

##  互斥量与信号量的区别

- 互斥量用于线程的互斥,信号线用于线程的同步

这是互斥量和信号量的根本区别,也就是互斥和同步之间的区别

互斥：是指某一资源同时只允许一个访问者对其进行访问,
具有唯一性和排它性.但互斥无法限制访问者对资源的访问顺序,即访问是无序的

同步：是指在互斥的基础上(大多数情况),通过其它机制实现访问者对资源的有序访问.
在大多数情况下,同步已经实现了互斥,特别是所有写入资源的情况必定是互斥的.
少数情况是指可以允许多个访问者同时访问资源

- 互斥量值只能为0/1,信号量值可以为非负整数

也就是说,一个互斥量只能用于一个资源的互斥访问,
它不能实现多个资源的多线程互斥问题.信号量可以实现多个同类资源的多线程互斥和同步.
当信号量为单值信号量是,也可以完成一个资源的互斥访问

- 互斥量的加锁和解锁必须由同一线程分别对应使用,
信号量可以由一个线程释放,另一个线程得到

## mutex和spin lock的区别

mutex和spin lock的区别和应用(sleep-waiting和busy-waiting的区别)

互斥mutex是`sleep-waiting`(可休眠)
就是说当没有获得mutex时,会有上下文切换,将自己、
加到忙等待队列中,直到另外一个线程释放mutex并唤醒它,
而这时CPU是空闲的,可以调度别的任务处理.

而自旋锁spin lock是`busy-waiting`
就是说当没有可用的锁时,就一直忙等待并不停的进行锁请求,
直到得到这个锁为止.这个过程中cpu始终处于忙状态,不能做别的任务.

例如在一个双核的机器上有两个线程(线程A和线程B),它们分别运行在Core0 和Core1上.
用spin-lock,coer0上的线程就会始终占用CPU.
另外一个值得注意的细节是spin lock耗费了更多的user time.
这是因为两个线程分别运行在两个核上,大部分时间只有一个线程能拿到锁,
所以另一个线程就一直在它运行的core上进行忙等待,CPU占用率一直是100%；
而mutex则不同,当对锁的请求失败后上下文切换就会发生,这样就能空出一个核来进行别的运算任务了
(其实这种上下文切换对已经拿着锁的那个线程性能也是有影响的,
因为当该线程释放该锁时它需要通知操作系统去唤醒那些被阻塞的线程,这也是额外的开销)

## 使用场景总结

- Mutex适合`对锁操作非常频繁`的场景,并且具有更好的适应性.
尽管相比spin lock它会花费更多的开销(主要是上下文切换),
但是它能适合实际开发中复杂的应用场景,在保证一定性能的前提下提供更大的灵活度.

- spin lock的lock/unlock性能更好(花费更少的cpu指令),
但是它只适应用于`临界区运行时间很短`的场景.
而在实际软件开发中,除非程序员对自己的程序的锁操作行为非常的了解,
否则使用spin lock不是一个好主意
(通常一个多线程程序中对锁的操作有数以万次,如果失败的锁操作
(contended lock requests)过多的话就会浪费很多的时间进行空等待).

- 更保险的方法或许是先(保守的)使用
Mutex,然后如果对性能还有进一步的需求,可以尝试使用spin
lock进行调优.毕竟我们的程序不像Linux kernel那样对性能需求那么高
(Linux Kernel最常用的锁操作是spin lock和rw lock).
