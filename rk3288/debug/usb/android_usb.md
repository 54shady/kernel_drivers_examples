# Android上USB调试

[内核文档usbmon.txt](https://www.kernel.org/doc/Documentation/usb/usbmon.txt)

[USB Sniffing with tcpdump](http://omappedia.org/wiki/USB_Sniffing_with_tcpdump)

[linux下的usb抓包方法](https://blog.csdn.net/xiaojsj111/article/details/14127607)

## 配置内核支持usbmonitor调试

```shell
make menuconfig
	Device Drivers -->
		USB Support -->
			USB Monitor --> Select * not M
```

检查是否存在目录(/sys/kernel/debug/usb/usbmon)
如果没有挂载debugfs则需要手动挂载

	mount -t debugfs none_debugs /sys/kernel/debug

```shell
#ls /sys/kernel/debug/usb/usbmon
0s  0u  1s  1t  1u  2s  2t  2u  3s  3t  3u
```
## 查看USB的RAW数据(USBMON)

### usbmon工作原理

- 把usb host drivers发送到hcd的所有请求(usb_submit_urb)
- 和请求的回调内容(即改请求对应的回调函数:urb->complete)都报告出来

### 基本调试信息

更具VID/PID找到需要调试的设备

	cat /sys/kernel/debug/usb/devices

假设是这下面的

	T:  Bus=01 Lev=02 Prnt=02 Port=00 Cnt=01 Dev#=  6 Spd=12   MxCh= 0
	D:  Ver= 2.00 Cls=00(>ifc ) Sub=00 Prot=00 MxPS=64 #Cfgs=  1

可以知道是总线1上的设备6

	Bus=01, Dev#= 6

抓取总线1上的数据

	cat /sys/kernel/debug/usb/usbmon/1u > 1u.out

假设数据如下

	c4b39280 80458961 C Ii:1:006:1 0:1 8 = 00002300 00000000
	c4b39280 80459085 S Ii:1:006:1 -115:1 8 <
	c4b39280 80459959 C Ii:1:006:1 0:1 8 = 00000000 00000000
	c4b39280 80460021 S Ii:1:006:1 -115:1 8 <
	c4b39280 80460958 C Ii:1:006:1 0:1 8 = 00002600 00000000
	c4b39280 80461031 S Ii:1:006:1 -115:1 8 <
	c4b39280 80461961 C Ii:1:006:1 0:1 8 = 00000000 00000000
	c4b39280 80462032 S Ii:1:006:1 -115:1 8 <
	c4b39280 80462960 C Ii:1:006:1 0:1 8 = 00002000 00000000
	c4b39280 80463030 S Ii:1:006:1 -115:1 8 <
	c4b39280 80463965 C Ii:1:006:1 0:1 8 = 00000000 00000000
	c4b39280 80464039 S Ii:1:006:1 -115:1 8 <
	c4b39280 80464958 C Ii:1:006:1 0:1 8 = 00002400 00000000
	c4b39280 80465033 S Ii:1:006:1 -115:1 8 <
	c4b39280 80465957 C Ii:1:006:1 0:1 8 = 00000000 00000000
	c4b39280 80466027 S Ii:1:006:1 -115:1 8 <
	c4b39280 80466901 C Ii:1:006:1 0:1 8 = 00002400 00000000
	c4b39280 80466994 S Ii:1:006:1 -115:1 8 <
	c4b39280 80467961 C Ii:1:006:1 0:1 8 = 00000000 00000000
	c4b39280 80468041 S Ii:1:006:1 -115:1 8 <
	c4b39280 80468957 C Ii:1:006:1 0:1 8 = 00002100 00000000
	c4b39280 80469032 S Ii:1:006:1 -115:1 8 <
	c4b39280 80469956 C Ii:1:006:1 0:1 8 = 00000000 00000000
	c4b39280 80470030 S Ii:1:006:1 -115:1 8 <
	c4b39280 80470984 C Ii:1:006:1 0:1 8 = 00002500 00000000
	c4b39280 80471054 S Ii:1:006:1 -115:1 8 <
	c4b39280 80471956 C Ii:1:006:1 0:1 8 = 00000000 00000000
	c4b39280 80472023 S Ii:1:006:1 -115:1 8 <
	c4b39280 80472956 C Ii:1:006:1 0:1 8 = 00002000 00000000
	c4b39280 80473029 S Ii:1:006:1 -115:1 8 <
	c4b39280 80473959 C Ii:1:006:1 0:1 8 = 00000000 00000000
	c4b39280 80474030 S Ii:1:006:1 -115:1 8 <
	c4b39280 80474958 C Ii:1:006:1 0:1 8 = 00002700 00000000
	c4b39280 80475032 S Ii:1:006:1 -115:1 8 <
	c4b39280 80475966 C Ii:1:006:1 0:1 8 = 00000000 00000000
	c4b39280 80476040 S Ii:1:006:1 -115:1 8 <
	c4b39280 80476958 C Ii:1:006:1 0:1 8 = 00002100 00000000
	c4b39280 80477035 S Ii:1:006:1 -115:1 8 <
	c4b39280 80477965 C Ii:1:006:1 0:1 8 = 00000000 00000000
	c4b39280 80478038 S Ii:1:006:1 -115:1 8 <
	c4b39280 80478957 C Ii:1:006:1 0:1 8 = 00002300 00000000
	c4b39280 80479035 S Ii:1:006:1 -115:1 8 <
	c4b39280 80479958 C Ii:1:006:1 0:1 8 = 00000000 00000000
	c4b39280 80480025 S Ii:1:006:1 -115:1 8 <
	c4b39280 80480964 C Ii:1:006:1 0:1 8 = 00002100 00000000
	c4b39280 80481031 S Ii:1:006:1 -115:1 8 <
	c4b39280 80481958 C Ii:1:006:1 0:1 8 = 00000000 00000000
	c4b39280 80482025 S Ii:1:006:1 -115:1 8 <
	c4b39280 80482957 C Ii:1:006:1 0:1 8 = 00002400 00000000
	c4b39280 80483030 S Ii:1:006:1 -115:1 8 <
	c4b39280 80483997 C Ii:1:006:1 0:1 8 = 00000000 00000000
	c4b39280 80484030 S Ii:1:006:1 -115:1 8 <
	c4b39280 80484953 C Ii:1:006:1 0:1 8 = 00002800 00000000
	c4b39280 80484994 S Ii:1:006:1 -115:1 8 <
	c4b39280 80485960 C Ii:1:006:1 0:1 8 = 00000000 00000000
	c4b39280 80485996 S Ii:1:006:1 -115:1 8 <

其中数据格式按列依次为

URB Tag(URB在内核中的地址,一般一个端口对应一个URB)

	一般是通过urb = usb_alloc_urb(0, mem_flags);分配的

Timestamp(时间戳, 单位是微妙)

Event Type

	S - submission, C - callback, E - submission error.
	S 对应usb_submit_urb
	C 对应urb->complete

"Address" word (formerly a "pipe").

    Ci Co   Control input and output
    Zi Zo   Isochronous input and output
    Ii Io   Interrupt input and output
    Bi Bo   Bulk input and output
	Aa:Bus number:Device address:Endpoint
	Ii:1:006:1表示Interrupt input总线1设备6端点1

URB Status

	中断传输: URB status:interval
	同步传输: URB status:interval:[start frame]:[error count]

通过getevent获得的数据(getevent /dev/input/event5)

	0004 0004 00070023
	0001 0007 00000001
	0000 0000 00000000
	0004 0004 00070023
	0001 0007 00000000
	0000 0000 00000000
	0004 0004 00070026
	0001 000a 00000001
	0000 0000 00000000
	0004 0004 00070026
	0001 000a 00000000
	0000 0000 00000000
	0004 0004 00070020
	0001 0004 00000001
	0000 0000 00000000
	0004 0004 00070020
	0001 0004 00000000
	0000 0000 00000000
	0004 0004 00070024
	0001 0008 00000001
	0000 0000 00000000
	0004 0004 00070024
	0001 0008 00000000
	0000 0000 00000000
	0004 0004 00070024
	0001 0008 00000001
	0000 0000 00000000
	0004 0004 00070024
	0001 0008 00000000
	0000 0000 00000000
	0004 0004 00070021
	0001 0005 00000001
	0000 0000 00000000
	0004 0004 00070021
	0001 0005 00000000
	0000 0000 00000000
	0004 0004 00070025
	0001 0009 00000001
	0000 0000 00000000
	0004 0004 00070025
	0001 0009 00000000
	0000 0000 00000000
	0004 0004 00070020
	0001 0004 00000001
	0000 0000 00000000
	0004 0004 00070020
	0001 0004 00000000
	0000 0000 00000000
	0004 0004 00070027
	0001 000b 00000001
	0000 0000 00000000
	0004 0004 00070027
	0001 000b 00000000
	0000 0000 00000000
	0004 0004 00070021
	0001 0005 00000001
	0000 0000 00000000
	0004 0004 00070021
	0001 0005 00000000
	0000 0000 00000000
	0004 0004 00070023
	0001 0007 00000001
	0000 0000 00000000
	0004 0004 00070023
	0001 0007 00000000
	0000 0000 00000000
	0004 0004 00070021
	0001 0005 00000001
	0000 0000 00000000
	0004 0004 00070021
	0001 0005 00000000
	0000 0000 00000000
	0004 0004 00070024
	0001 0008 00000001
	0000 0000 00000000
	0004 0004 00070024
	0001 0008 00000000
	0000 0000 00000000
	0004 0004 00070028
	0001 001c 00000001
	0000 0000 00000000
	0004 0004 00070028
	0001 001c 00000000
	0000 0000 00000000

## 使用wireshark分析数据

查看所有连接的USB设备

	cat /sys/kernel/debug/usb/devices

	T:  Bus=03 Lev=00 Prnt=00 Port=00 Cnt=00 Dev#=  1 Spd=480  MxCh= 1
	B:  Alloc=  0/800 us ( 0%), #Int=  0, #Iso=  0
	D:  Ver= 2.00 Cls=09(hub  ) Sub=00 Prot=01 MxPS=64 #Cfgs=  1
	P:  Vendor=1d6b ProdID=0002 Rev= 3.10
	S:  Manufacturer=Linux 3.10.0 dwc_otg_hcd
	S:  Product=DWC OTG Controller
	S:  SerialNumber=ff540000.usb
	C:* #Ifs= 1 Cfg#= 1 Atr=e0 MxPwr=  0mA
	I:* If#= 0 Alt= 0 #EPs= 1 Cls=09(hub  ) Sub=00 Prot=00 Driver=hub
	E:  Ad=81(I) Atr=03(Int.) MxPS=   4 Ivl=256ms

使用tcpdump查看是否支持usbmon

	tcpdump -D
	1.eth0
	2.nfqueue (Linux netfilter queue (NFQUEUE) interface)
	3.usbmon1 (USB bus number 1)
	4.usbmon2 (USB bus number 2)
	5.usbmon3 (USB bus number 3)
	6.any (Pseudo-device that captures on all interfaces)
	7.lo

## 抓取USB总线上的数据

抓取USB Bus3 上的数据

	tcpdump -i usbmon3 -w usb.pcap &

停止采集数据

	killall tcpdump

## 分析相应的结果

使用wireshark分析usb.pcap文件
